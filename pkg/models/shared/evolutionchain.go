// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type EvolutionChainBabyTriggerItemType string

const (
	EvolutionChainBabyTriggerItemTypeItem EvolutionChainBabyTriggerItemType = "Item"
)

type EvolutionChainBabyTriggerItem struct {
	Item *Item

	Type EvolutionChainBabyTriggerItemType
}

func CreateEvolutionChainBabyTriggerItemItem(item Item) EvolutionChainBabyTriggerItem {
	typ := EvolutionChainBabyTriggerItemTypeItem

	return EvolutionChainBabyTriggerItem{
		Item: &item,
		Type: typ,
	}
}

func (u *EvolutionChainBabyTriggerItem) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	item := new(Item)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&item); err == nil {
		u.Item = item
		u.Type = EvolutionChainBabyTriggerItemTypeItem
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainBabyTriggerItem) MarshalJSON() ([]byte, error) {
	if u.Item != nil {
		return json.Marshal(u.Item)
	}

	return nil, nil
}

type EvolutionChainChainEvolutionDetailsHeldItemType string

const (
	EvolutionChainChainEvolutionDetailsHeldItemTypeItem EvolutionChainChainEvolutionDetailsHeldItemType = "Item"
)

type EvolutionChainChainEvolutionDetailsHeldItem struct {
	Item *Item

	Type EvolutionChainChainEvolutionDetailsHeldItemType
}

func CreateEvolutionChainChainEvolutionDetailsHeldItemItem(item Item) EvolutionChainChainEvolutionDetailsHeldItem {
	typ := EvolutionChainChainEvolutionDetailsHeldItemTypeItem

	return EvolutionChainChainEvolutionDetailsHeldItem{
		Item: &item,
		Type: typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsHeldItem) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	item := new(Item)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&item); err == nil {
		u.Item = item
		u.Type = EvolutionChainChainEvolutionDetailsHeldItemTypeItem
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsHeldItem) MarshalJSON() ([]byte, error) {
	if u.Item != nil {
		return json.Marshal(u.Item)
	}

	return nil, nil
}

type EvolutionChainChainEvolutionDetailsItemType string

const (
	EvolutionChainChainEvolutionDetailsItemTypeItem EvolutionChainChainEvolutionDetailsItemType = "Item"
)

type EvolutionChainChainEvolutionDetailsItem struct {
	Item *Item

	Type EvolutionChainChainEvolutionDetailsItemType
}

func CreateEvolutionChainChainEvolutionDetailsItemItem(item Item) EvolutionChainChainEvolutionDetailsItem {
	typ := EvolutionChainChainEvolutionDetailsItemTypeItem

	return EvolutionChainChainEvolutionDetailsItem{
		Item: &item,
		Type: typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsItem) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	item := new(Item)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&item); err == nil {
		u.Item = item
		u.Type = EvolutionChainChainEvolutionDetailsItemTypeItem
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsItem) MarshalJSON() ([]byte, error) {
	if u.Item != nil {
		return json.Marshal(u.Item)
	}

	return nil, nil
}

type EvolutionChainChainEvolutionDetailsKnownMoveType string

const (
	EvolutionChainChainEvolutionDetailsKnownMoveTypeMove EvolutionChainChainEvolutionDetailsKnownMoveType = "Move"
)

type EvolutionChainChainEvolutionDetailsKnownMove struct {
	Move *Move

	Type EvolutionChainChainEvolutionDetailsKnownMoveType
}

func CreateEvolutionChainChainEvolutionDetailsKnownMoveMove(move Move) EvolutionChainChainEvolutionDetailsKnownMove {
	typ := EvolutionChainChainEvolutionDetailsKnownMoveTypeMove

	return EvolutionChainChainEvolutionDetailsKnownMove{
		Move: &move,
		Type: typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsKnownMove) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	move := new(Move)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&move); err == nil {
		u.Move = move
		u.Type = EvolutionChainChainEvolutionDetailsKnownMoveTypeMove
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsKnownMove) MarshalJSON() ([]byte, error) {
	if u.Move != nil {
		return json.Marshal(u.Move)
	}

	return nil, nil
}

type EvolutionChainChainEvolutionDetailsKnownMoveTypeType string

const (
	EvolutionChainChainEvolutionDetailsKnownMoveTypeTypeType EvolutionChainChainEvolutionDetailsKnownMoveTypeType = "Type"
)

type EvolutionChainChainEvolutionDetailsKnownMoveType struct {
	Type *Type

	Type EvolutionChainChainEvolutionDetailsKnownMoveTypeType
}

func CreateEvolutionChainChainEvolutionDetailsKnownMoveTypeType(typeT Type) EvolutionChainChainEvolutionDetailsKnownMoveType {
	typ := EvolutionChainChainEvolutionDetailsKnownMoveTypeTypeType

	return EvolutionChainChainEvolutionDetailsKnownMoveType{
		Type: &typeT,
		Type: typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsKnownMoveType) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	typeVar := new(Type)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&typeVar); err == nil {
		u.Type = typeVar
		u.Type = EvolutionChainChainEvolutionDetailsKnownMoveTypeTypeType
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsKnownMoveType) MarshalJSON() ([]byte, error) {
	if u.Type != nil {
		return json.Marshal(u.Type)
	}

	return nil, nil
}

type EvolutionChainChainEvolutionDetailsLocationType string

const (
	EvolutionChainChainEvolutionDetailsLocationTypeLocation EvolutionChainChainEvolutionDetailsLocationType = "Location"
)

type EvolutionChainChainEvolutionDetailsLocation struct {
	Location *Location

	Type EvolutionChainChainEvolutionDetailsLocationType
}

func CreateEvolutionChainChainEvolutionDetailsLocationLocation(location Location) EvolutionChainChainEvolutionDetailsLocation {
	typ := EvolutionChainChainEvolutionDetailsLocationTypeLocation

	return EvolutionChainChainEvolutionDetailsLocation{
		Location: &location,
		Type:     typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsLocation) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	location := new(Location)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&location); err == nil {
		u.Location = location
		u.Type = EvolutionChainChainEvolutionDetailsLocationTypeLocation
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsLocation) MarshalJSON() ([]byte, error) {
	if u.Location != nil {
		return json.Marshal(u.Location)
	}

	return nil, nil
}

type EvolutionChainChainEvolutionDetailsPartySpeciesType string

const (
	EvolutionChainChainEvolutionDetailsPartySpeciesTypePokemonSpecies EvolutionChainChainEvolutionDetailsPartySpeciesType = "PokemonSpecies"
)

type EvolutionChainChainEvolutionDetailsPartySpecies struct {
	PokemonSpecies *PokemonSpecies

	Type EvolutionChainChainEvolutionDetailsPartySpeciesType
}

func CreateEvolutionChainChainEvolutionDetailsPartySpeciesPokemonSpecies(pokemonSpecies PokemonSpecies) EvolutionChainChainEvolutionDetailsPartySpecies {
	typ := EvolutionChainChainEvolutionDetailsPartySpeciesTypePokemonSpecies

	return EvolutionChainChainEvolutionDetailsPartySpecies{
		PokemonSpecies: &pokemonSpecies,
		Type:           typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsPartySpecies) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	pokemonSpecies := new(PokemonSpecies)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&pokemonSpecies); err == nil {
		u.PokemonSpecies = pokemonSpecies
		u.Type = EvolutionChainChainEvolutionDetailsPartySpeciesTypePokemonSpecies
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsPartySpecies) MarshalJSON() ([]byte, error) {
	if u.PokemonSpecies != nil {
		return json.Marshal(u.PokemonSpecies)
	}

	return nil, nil
}

type EvolutionChainChainEvolutionDetailsPartyTypeType string

const (
	EvolutionChainChainEvolutionDetailsPartyTypeTypeType EvolutionChainChainEvolutionDetailsPartyTypeType = "Type"
)

type EvolutionChainChainEvolutionDetailsPartyType struct {
	Type *Type

	Type EvolutionChainChainEvolutionDetailsPartyTypeType
}

func CreateEvolutionChainChainEvolutionDetailsPartyTypeType(typeT Type) EvolutionChainChainEvolutionDetailsPartyType {
	typ := EvolutionChainChainEvolutionDetailsPartyTypeTypeType

	return EvolutionChainChainEvolutionDetailsPartyType{
		Type: &typeT,
		Type: typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsPartyType) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	typeVar := new(Type)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&typeVar); err == nil {
		u.Type = typeVar
		u.Type = EvolutionChainChainEvolutionDetailsPartyTypeTypeType
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsPartyType) MarshalJSON() ([]byte, error) {
	if u.Type != nil {
		return json.Marshal(u.Type)
	}

	return nil, nil
}

// EvolutionChainChainEvolutionDetailsTimeOfDay - The required time of day. Day or night.
type EvolutionChainChainEvolutionDetailsTimeOfDay string

const (
	EvolutionChainChainEvolutionDetailsTimeOfDayDay   EvolutionChainChainEvolutionDetailsTimeOfDay = "day"
	EvolutionChainChainEvolutionDetailsTimeOfDayNight EvolutionChainChainEvolutionDetailsTimeOfDay = "night"
)

func (e EvolutionChainChainEvolutionDetailsTimeOfDay) ToPointer() *EvolutionChainChainEvolutionDetailsTimeOfDay {
	return &e
}

func (e *EvolutionChainChainEvolutionDetailsTimeOfDay) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "day":
		fallthrough
	case "night":
		*e = EvolutionChainChainEvolutionDetailsTimeOfDay(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EvolutionChainChainEvolutionDetailsTimeOfDay: %v", v)
	}
}

type EvolutionChainChainEvolutionDetailsTradeSpeciesType string

const (
	EvolutionChainChainEvolutionDetailsTradeSpeciesTypePokemonSpecies EvolutionChainChainEvolutionDetailsTradeSpeciesType = "PokemonSpecies"
)

type EvolutionChainChainEvolutionDetailsTradeSpecies struct {
	PokemonSpecies *PokemonSpecies

	Type EvolutionChainChainEvolutionDetailsTradeSpeciesType
}

func CreateEvolutionChainChainEvolutionDetailsTradeSpeciesPokemonSpecies(pokemonSpecies PokemonSpecies) EvolutionChainChainEvolutionDetailsTradeSpecies {
	typ := EvolutionChainChainEvolutionDetailsTradeSpeciesTypePokemonSpecies

	return EvolutionChainChainEvolutionDetailsTradeSpecies{
		PokemonSpecies: &pokemonSpecies,
		Type:           typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsTradeSpecies) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	pokemonSpecies := new(PokemonSpecies)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&pokemonSpecies); err == nil {
		u.PokemonSpecies = pokemonSpecies
		u.Type = EvolutionChainChainEvolutionDetailsTradeSpeciesTypePokemonSpecies
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsTradeSpecies) MarshalJSON() ([]byte, error) {
	if u.PokemonSpecies != nil {
		return json.Marshal(u.PokemonSpecies)
	}

	return nil, nil
}

type EvolutionChainChainEvolutionDetails struct {
	// The required female gender of the evolving Pokémon species. Must be either 1 or 2, or null if the Pokémon species has no gender or the gender is fixed.
	Gender        *int64                                            `json:"gender,omitempty"`
	HeldItem      *EvolutionChainChainEvolutionDetailsHeldItem      `json:"held_item,omitempty"`
	Item          *EvolutionChainChainEvolutionDetailsItem          `json:"item,omitempty"`
	KnownMove     *EvolutionChainChainEvolutionDetailsKnownMove     `json:"known_move,omitempty"`
	KnownMoveType *EvolutionChainChainEvolutionDetailsKnownMoveType `json:"known_move_type,omitempty"`
	Location      *EvolutionChainChainEvolutionDetailsLocation      `json:"location,omitempty"`
	// The minimum required affection of the evolving Pokémon species
	MinAffection *int64 `json:"min_affection,omitempty"`
	// The minimum required beauty of the evolving Pokémon species
	MinBeauty *int64 `json:"min_beauty,omitempty"`
	// The minimum required happiness of the evolving Pokémon species
	MinHappiness *int64 `json:"min_happiness,omitempty"`
	// The minimum required level of the evolving Pokémon species
	MinLevel *int64 `json:"min_level,omitempty"`
	// Whether or not it must be raining in the overworld to evolve into this Pokémon species
	NeedsOverworldRain *bool                                            `json:"needs_overworld_rain,omitempty"`
	PartySpecies       *EvolutionChainChainEvolutionDetailsPartySpecies `json:"party_species,omitempty"`
	PartyType          *EvolutionChainChainEvolutionDetailsPartyType    `json:"party_type,omitempty"`
	// The required relation between the Pokémon's Attack and Defense stats. 1 means Attack > Defense, 0 means Attack = Defense, and -1 means Attack < Defense.
	RelativePhysicalStats *int64 `json:"relative_physical_stats,omitempty"`
	// The required time of day. Day or night.
	TimeOfDay    *EvolutionChainChainEvolutionDetailsTimeOfDay    `json:"time_of_day,omitempty"`
	TradeSpecies *EvolutionChainChainEvolutionDetailsTradeSpecies `json:"trade_species,omitempty"`
	Trigger      *EvolutionTrigger                                `json:"trigger,omitempty"`
	// Whether or not the 3DS needs to be turned upside-down as this Pokémon levels up.
	TurnUpsideDown *bool `json:"turn_upside_down,omitempty"`
}

func (o *EvolutionChainChainEvolutionDetails) GetGender() *int64 {
	if o == nil {
		return nil
	}
	return o.Gender
}

func (o *EvolutionChainChainEvolutionDetails) GetHeldItem() *EvolutionChainChainEvolutionDetailsHeldItem {
	if o == nil {
		return nil
	}
	return o.HeldItem
}

func (o *EvolutionChainChainEvolutionDetails) GetItem() *EvolutionChainChainEvolutionDetailsItem {
	if o == nil {
		return nil
	}
	return o.Item
}

func (o *EvolutionChainChainEvolutionDetails) GetKnownMove() *EvolutionChainChainEvolutionDetailsKnownMove {
	if o == nil {
		return nil
	}
	return o.KnownMove
}

func (o *EvolutionChainChainEvolutionDetails) GetKnownMoveType() *EvolutionChainChainEvolutionDetailsKnownMoveType {
	if o == nil {
		return nil
	}
	return o.KnownMoveType
}

func (o *EvolutionChainChainEvolutionDetails) GetLocation() *EvolutionChainChainEvolutionDetailsLocation {
	if o == nil {
		return nil
	}
	return o.Location
}

func (o *EvolutionChainChainEvolutionDetails) GetMinAffection() *int64 {
	if o == nil {
		return nil
	}
	return o.MinAffection
}

func (o *EvolutionChainChainEvolutionDetails) GetMinBeauty() *int64 {
	if o == nil {
		return nil
	}
	return o.MinBeauty
}

func (o *EvolutionChainChainEvolutionDetails) GetMinHappiness() *int64 {
	if o == nil {
		return nil
	}
	return o.MinHappiness
}

func (o *EvolutionChainChainEvolutionDetails) GetMinLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.MinLevel
}

func (o *EvolutionChainChainEvolutionDetails) GetNeedsOverworldRain() *bool {
	if o == nil {
		return nil
	}
	return o.NeedsOverworldRain
}

func (o *EvolutionChainChainEvolutionDetails) GetPartySpecies() *EvolutionChainChainEvolutionDetailsPartySpecies {
	if o == nil {
		return nil
	}
	return o.PartySpecies
}

func (o *EvolutionChainChainEvolutionDetails) GetPartyType() *EvolutionChainChainEvolutionDetailsPartyType {
	if o == nil {
		return nil
	}
	return o.PartyType
}

func (o *EvolutionChainChainEvolutionDetails) GetRelativePhysicalStats() *int64 {
	if o == nil {
		return nil
	}
	return o.RelativePhysicalStats
}

func (o *EvolutionChainChainEvolutionDetails) GetTimeOfDay() *EvolutionChainChainEvolutionDetailsTimeOfDay {
	if o == nil {
		return nil
	}
	return o.TimeOfDay
}

func (o *EvolutionChainChainEvolutionDetails) GetTradeSpecies() *EvolutionChainChainEvolutionDetailsTradeSpecies {
	if o == nil {
		return nil
	}
	return o.TradeSpecies
}

func (o *EvolutionChainChainEvolutionDetails) GetTrigger() *EvolutionTrigger {
	if o == nil {
		return nil
	}
	return o.Trigger
}

func (o *EvolutionChainChainEvolutionDetails) GetTurnUpsideDown() *bool {
	if o == nil {
		return nil
	}
	return o.TurnUpsideDown
}

type EvolutionChainChain struct {
	// The chain of Pokémon species that forms part of this evolution chain
	EvolutionDetails []EvolutionChainChainEvolutionDetails `json:"evolution_details,omitempty"`
	// Whether or not this is a baby Pokémon
	IsBaby  *bool           `json:"is_baby,omitempty"`
	Species *PokemonSpecies `json:"species,omitempty"`
}

func (o *EvolutionChainChain) GetEvolutionDetails() []EvolutionChainChainEvolutionDetails {
	if o == nil {
		return nil
	}
	return o.EvolutionDetails
}

func (o *EvolutionChainChain) GetIsBaby() *bool {
	if o == nil {
		return nil
	}
	return o.IsBaby
}

func (o *EvolutionChainChain) GetSpecies() *PokemonSpecies {
	if o == nil {
		return nil
	}
	return o.Species
}

// EvolutionChain - Successful response
type EvolutionChain struct {
	// The item that a baby Pokémon would be holding when born during a forced evolution
	BabyTriggerItem *EvolutionChainBabyTriggerItem `json:"baby_trigger_item,omitempty"`
	Chain           EvolutionChainChain            `json:"chain"`
	// The identifier for this evolution chain resource
	ID int64 `json:"id"`
}

func (o *EvolutionChain) GetBabyTriggerItem() *EvolutionChainBabyTriggerItem {
	if o == nil {
		return nil
	}
	return o.BabyTriggerItem
}

func (o *EvolutionChain) GetChain() EvolutionChainChain {
	if o == nil {
		return EvolutionChainChain{}
	}
	return o.Chain
}

func (o *EvolutionChain) GetID() int64 {
	if o == nil {
		return 0
	}
	return o.ID
}
