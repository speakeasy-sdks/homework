// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"homework/pkg/utils"
)

// EvolutionChainBabyTriggerItemItem - The item that a baby Pok√©mon would be holding when born during a forced evolution
type EvolutionChainBabyTriggerItemItem struct {
	Attributes        []ItemAttribute  `json:"attributes,omitempty"`
	Category          *ItemCategory    `json:"category,omitempty"`
	Cost              *int             `json:"cost,omitempty"`
	EffectEntries     []VerboseEffect  `json:"effect_entries,omitempty"`
	FlavorTextEntries []FlavorText     `json:"flavor_text_entries,omitempty"`
	FlingEffect       *ItemFlingEffect `json:"fling_effect,omitempty"`
	FlingPower        *int             `json:"fling_power,omitempty"`
	ID                *int             `json:"id,omitempty"`
	Name              *string          `json:"name,omitempty"`
}

func (o *EvolutionChainBabyTriggerItemItem) GetAttributes() []ItemAttribute {
	if o == nil {
		return nil
	}
	return o.Attributes
}

func (o *EvolutionChainBabyTriggerItemItem) GetCategory() *ItemCategory {
	if o == nil {
		return nil
	}
	return o.Category
}

func (o *EvolutionChainBabyTriggerItemItem) GetCost() *int {
	if o == nil {
		return nil
	}
	return o.Cost
}

func (o *EvolutionChainBabyTriggerItemItem) GetEffectEntries() []VerboseEffect {
	if o == nil {
		return nil
	}
	return o.EffectEntries
}

func (o *EvolutionChainBabyTriggerItemItem) GetFlavorTextEntries() []FlavorText {
	if o == nil {
		return nil
	}
	return o.FlavorTextEntries
}

func (o *EvolutionChainBabyTriggerItemItem) GetFlingEffect() *ItemFlingEffect {
	if o == nil {
		return nil
	}
	return o.FlingEffect
}

func (o *EvolutionChainBabyTriggerItemItem) GetFlingPower() *int {
	if o == nil {
		return nil
	}
	return o.FlingPower
}

func (o *EvolutionChainBabyTriggerItemItem) GetID() *int {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *EvolutionChainBabyTriggerItemItem) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

type EvolutionChainBabyTriggerItemType string

const (
	EvolutionChainBabyTriggerItemTypeEvolutionChainBabyTriggerItemItem EvolutionChainBabyTriggerItemType = "EvolutionChain_baby_trigger_item_Item"
)

type EvolutionChainBabyTriggerItem struct {
	EvolutionChainBabyTriggerItemItem *EvolutionChainBabyTriggerItemItem

	Type EvolutionChainBabyTriggerItemType
}

func CreateEvolutionChainBabyTriggerItemEvolutionChainBabyTriggerItemItem(evolutionChainBabyTriggerItemItem EvolutionChainBabyTriggerItemItem) EvolutionChainBabyTriggerItem {
	typ := EvolutionChainBabyTriggerItemTypeEvolutionChainBabyTriggerItemItem

	return EvolutionChainBabyTriggerItem{
		EvolutionChainBabyTriggerItemItem: &evolutionChainBabyTriggerItemItem,
		Type:                              typ,
	}
}

func (u *EvolutionChainBabyTriggerItem) UnmarshalJSON(data []byte) error {

	evolutionChainBabyTriggerItemItem := EvolutionChainBabyTriggerItemItem{}
	if err := utils.UnmarshalJSON(data, &evolutionChainBabyTriggerItemItem, "", true, true); err == nil {
		u.EvolutionChainBabyTriggerItemItem = &evolutionChainBabyTriggerItemItem
		u.Type = EvolutionChainBabyTriggerItemTypeEvolutionChainBabyTriggerItemItem
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainBabyTriggerItem) MarshalJSON() ([]byte, error) {
	if u.EvolutionChainBabyTriggerItemItem != nil {
		return utils.MarshalJSON(u.EvolutionChainBabyTriggerItemItem, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type EvolutionChainChainEvolutionDetailsHeldItemType string

const (
	EvolutionChainChainEvolutionDetailsHeldItemTypeItem EvolutionChainChainEvolutionDetailsHeldItemType = "Item"
)

type EvolutionChainChainEvolutionDetailsHeldItem struct {
	Item *Item

	Type EvolutionChainChainEvolutionDetailsHeldItemType
}

func CreateEvolutionChainChainEvolutionDetailsHeldItemItem(item Item) EvolutionChainChainEvolutionDetailsHeldItem {
	typ := EvolutionChainChainEvolutionDetailsHeldItemTypeItem

	return EvolutionChainChainEvolutionDetailsHeldItem{
		Item: &item,
		Type: typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsHeldItem) UnmarshalJSON(data []byte) error {

	item := Item{}
	if err := utils.UnmarshalJSON(data, &item, "", true, true); err == nil {
		u.Item = &item
		u.Type = EvolutionChainChainEvolutionDetailsHeldItemTypeItem
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsHeldItem) MarshalJSON() ([]byte, error) {
	if u.Item != nil {
		return utils.MarshalJSON(u.Item, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type EvolutionChainChainEvolutionDetailsItemType string

const (
	EvolutionChainChainEvolutionDetailsItemTypeItem EvolutionChainChainEvolutionDetailsItemType = "Item"
)

type EvolutionChainChainEvolutionDetailsItem struct {
	Item *Item

	Type EvolutionChainChainEvolutionDetailsItemType
}

func CreateEvolutionChainChainEvolutionDetailsItemItem(item Item) EvolutionChainChainEvolutionDetailsItem {
	typ := EvolutionChainChainEvolutionDetailsItemTypeItem

	return EvolutionChainChainEvolutionDetailsItem{
		Item: &item,
		Type: typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsItem) UnmarshalJSON(data []byte) error {

	item := Item{}
	if err := utils.UnmarshalJSON(data, &item, "", true, true); err == nil {
		u.Item = &item
		u.Type = EvolutionChainChainEvolutionDetailsItemTypeItem
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsItem) MarshalJSON() ([]byte, error) {
	if u.Item != nil {
		return utils.MarshalJSON(u.Item, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type EvolutionChainChainEvolutionDetailsKnownMoveType string

const (
	EvolutionChainChainEvolutionDetailsKnownMoveTypeMove EvolutionChainChainEvolutionDetailsKnownMoveType = "Move"
)

type EvolutionChainChainEvolutionDetailsKnownMove struct {
	Move *Move

	Type EvolutionChainChainEvolutionDetailsKnownMoveType
}

func CreateEvolutionChainChainEvolutionDetailsKnownMoveMove(move Move) EvolutionChainChainEvolutionDetailsKnownMove {
	typ := EvolutionChainChainEvolutionDetailsKnownMoveTypeMove

	return EvolutionChainChainEvolutionDetailsKnownMove{
		Move: &move,
		Type: typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsKnownMove) UnmarshalJSON(data []byte) error {

	move := Move{}
	if err := utils.UnmarshalJSON(data, &move, "", true, true); err == nil {
		u.Move = &move
		u.Type = EvolutionChainChainEvolutionDetailsKnownMoveTypeMove
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsKnownMove) MarshalJSON() ([]byte, error) {
	if u.Move != nil {
		return utils.MarshalJSON(u.Move, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type EvolutionChainChainEvolutionDetailsKnownMoveTypeType string

const (
	EvolutionChainChainEvolutionDetailsKnownMoveTypeTypeType EvolutionChainChainEvolutionDetailsKnownMoveTypeType = "Type"
)

type EvolutionChainChainEvolutionDetailsKnownMoveType struct {
	Type *Type

	Type EvolutionChainChainEvolutionDetailsKnownMoveTypeType
}

func CreateEvolutionChainChainEvolutionDetailsKnownMoveTypeType(typeT Type) EvolutionChainChainEvolutionDetailsKnownMoveType {
	typ := EvolutionChainChainEvolutionDetailsKnownMoveTypeTypeType

	return EvolutionChainChainEvolutionDetailsKnownMoveType{
		Type: &typeT,
		Type: typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsKnownMoveType) UnmarshalJSON(data []byte) error {

	typeVar := Type{}
	if err := utils.UnmarshalJSON(data, &typeVar, "", true, true); err == nil {
		u.Type = &typeVar
		u.Type = EvolutionChainChainEvolutionDetailsKnownMoveTypeTypeType
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsKnownMoveType) MarshalJSON() ([]byte, error) {
	if u.Type != nil {
		return utils.MarshalJSON(u.Type, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type EvolutionChainChainEvolutionDetailsLocationType string

const (
	EvolutionChainChainEvolutionDetailsLocationTypeLocation EvolutionChainChainEvolutionDetailsLocationType = "Location"
)

type EvolutionChainChainEvolutionDetailsLocation struct {
	Location *Location

	Type EvolutionChainChainEvolutionDetailsLocationType
}

func CreateEvolutionChainChainEvolutionDetailsLocationLocation(location Location) EvolutionChainChainEvolutionDetailsLocation {
	typ := EvolutionChainChainEvolutionDetailsLocationTypeLocation

	return EvolutionChainChainEvolutionDetailsLocation{
		Location: &location,
		Type:     typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsLocation) UnmarshalJSON(data []byte) error {

	location := Location{}
	if err := utils.UnmarshalJSON(data, &location, "", true, true); err == nil {
		u.Location = &location
		u.Type = EvolutionChainChainEvolutionDetailsLocationTypeLocation
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsLocation) MarshalJSON() ([]byte, error) {
	if u.Location != nil {
		return utils.MarshalJSON(u.Location, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type EvolutionChainChainEvolutionDetailsPartySpeciesType string

const (
	EvolutionChainChainEvolutionDetailsPartySpeciesTypePokemonSpecies EvolutionChainChainEvolutionDetailsPartySpeciesType = "PokemonSpecies"
)

type EvolutionChainChainEvolutionDetailsPartySpecies struct {
	PokemonSpecies *PokemonSpecies

	Type EvolutionChainChainEvolutionDetailsPartySpeciesType
}

func CreateEvolutionChainChainEvolutionDetailsPartySpeciesPokemonSpecies(pokemonSpecies PokemonSpecies) EvolutionChainChainEvolutionDetailsPartySpecies {
	typ := EvolutionChainChainEvolutionDetailsPartySpeciesTypePokemonSpecies

	return EvolutionChainChainEvolutionDetailsPartySpecies{
		PokemonSpecies: &pokemonSpecies,
		Type:           typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsPartySpecies) UnmarshalJSON(data []byte) error {

	pokemonSpecies := PokemonSpecies{}
	if err := utils.UnmarshalJSON(data, &pokemonSpecies, "", true, true); err == nil {
		u.PokemonSpecies = &pokemonSpecies
		u.Type = EvolutionChainChainEvolutionDetailsPartySpeciesTypePokemonSpecies
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsPartySpecies) MarshalJSON() ([]byte, error) {
	if u.PokemonSpecies != nil {
		return utils.MarshalJSON(u.PokemonSpecies, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type EvolutionChainChainEvolutionDetailsPartyTypeType string

const (
	EvolutionChainChainEvolutionDetailsPartyTypeTypeType EvolutionChainChainEvolutionDetailsPartyTypeType = "Type"
)

type EvolutionChainChainEvolutionDetailsPartyType struct {
	Type *Type

	Type EvolutionChainChainEvolutionDetailsPartyTypeType
}

func CreateEvolutionChainChainEvolutionDetailsPartyTypeType(typeT Type) EvolutionChainChainEvolutionDetailsPartyType {
	typ := EvolutionChainChainEvolutionDetailsPartyTypeTypeType

	return EvolutionChainChainEvolutionDetailsPartyType{
		Type: &typeT,
		Type: typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsPartyType) UnmarshalJSON(data []byte) error {

	typeVar := Type{}
	if err := utils.UnmarshalJSON(data, &typeVar, "", true, true); err == nil {
		u.Type = &typeVar
		u.Type = EvolutionChainChainEvolutionDetailsPartyTypeTypeType
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsPartyType) MarshalJSON() ([]byte, error) {
	if u.Type != nil {
		return utils.MarshalJSON(u.Type, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// EvolutionChainChainEvolutionDetailsTimeOfDay - The required time of day. Day or night.
type EvolutionChainChainEvolutionDetailsTimeOfDay string

const (
	EvolutionChainChainEvolutionDetailsTimeOfDayDay   EvolutionChainChainEvolutionDetailsTimeOfDay = "day"
	EvolutionChainChainEvolutionDetailsTimeOfDayNight EvolutionChainChainEvolutionDetailsTimeOfDay = "night"
)

func (e EvolutionChainChainEvolutionDetailsTimeOfDay) ToPointer() *EvolutionChainChainEvolutionDetailsTimeOfDay {
	return &e
}

func (e *EvolutionChainChainEvolutionDetailsTimeOfDay) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "day":
		fallthrough
	case "night":
		*e = EvolutionChainChainEvolutionDetailsTimeOfDay(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EvolutionChainChainEvolutionDetailsTimeOfDay: %v", v)
	}
}

type EvolutionChainChainEvolutionDetailsTradeSpeciesType string

const (
	EvolutionChainChainEvolutionDetailsTradeSpeciesTypePokemonSpecies EvolutionChainChainEvolutionDetailsTradeSpeciesType = "PokemonSpecies"
)

type EvolutionChainChainEvolutionDetailsTradeSpecies struct {
	PokemonSpecies *PokemonSpecies

	Type EvolutionChainChainEvolutionDetailsTradeSpeciesType
}

func CreateEvolutionChainChainEvolutionDetailsTradeSpeciesPokemonSpecies(pokemonSpecies PokemonSpecies) EvolutionChainChainEvolutionDetailsTradeSpecies {
	typ := EvolutionChainChainEvolutionDetailsTradeSpeciesTypePokemonSpecies

	return EvolutionChainChainEvolutionDetailsTradeSpecies{
		PokemonSpecies: &pokemonSpecies,
		Type:           typ,
	}
}

func (u *EvolutionChainChainEvolutionDetailsTradeSpecies) UnmarshalJSON(data []byte) error {

	pokemonSpecies := PokemonSpecies{}
	if err := utils.UnmarshalJSON(data, &pokemonSpecies, "", true, true); err == nil {
		u.PokemonSpecies = &pokemonSpecies
		u.Type = EvolutionChainChainEvolutionDetailsTradeSpeciesTypePokemonSpecies
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u EvolutionChainChainEvolutionDetailsTradeSpecies) MarshalJSON() ([]byte, error) {
	if u.PokemonSpecies != nil {
		return utils.MarshalJSON(u.PokemonSpecies, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type EvolutionChainChainEvolutionDetails struct {
	// The required female gender of the evolving Pok√©mon species. Must be either 1 or 2, or null if the Pok√©mon species has no gender or the gender is fixed.
	Gender        *int64                                            `json:"gender,omitempty"`
	HeldItem      *EvolutionChainChainEvolutionDetailsHeldItem      `json:"held_item,omitempty"`
	Item          *EvolutionChainChainEvolutionDetailsItem          `json:"item,omitempty"`
	KnownMove     *EvolutionChainChainEvolutionDetailsKnownMove     `json:"known_move,omitempty"`
	KnownMoveType *EvolutionChainChainEvolutionDetailsKnownMoveType `json:"known_move_type,omitempty"`
	Location      *EvolutionChainChainEvolutionDetailsLocation      `json:"location,omitempty"`
	// The minimum required affection of the evolving Pok√©mon species
	MinAffection *int64 `json:"min_affection,omitempty"`
	// The minimum required beauty of the evolving Pok√©mon species
	MinBeauty *int64 `json:"min_beauty,omitempty"`
	// The minimum required happiness of the evolving Pok√©mon species
	MinHappiness *int64 `json:"min_happiness,omitempty"`
	// The minimum required level of the evolving Pok√©mon species
	MinLevel *int64 `json:"min_level,omitempty"`
	// Whether or not it must be raining in the overworld to evolve into this Pok√©mon species
	NeedsOverworldRain *bool                                            `json:"needs_overworld_rain,omitempty"`
	PartySpecies       *EvolutionChainChainEvolutionDetailsPartySpecies `json:"party_species,omitempty"`
	PartyType          *EvolutionChainChainEvolutionDetailsPartyType    `json:"party_type,omitempty"`
	// The required relation between the Pok√©mon's Attack and Defense stats. 1 means Attack > Defense, 0 means Attack = Defense, and -1 means Attack < Defense.
	RelativePhysicalStats *int64 `json:"relative_physical_stats,omitempty"`
	// The required time of day. Day or night.
	TimeOfDay    *EvolutionChainChainEvolutionDetailsTimeOfDay    `json:"time_of_day,omitempty"`
	TradeSpecies *EvolutionChainChainEvolutionDetailsTradeSpecies `json:"trade_species,omitempty"`
	Trigger      *EvolutionTrigger                                `json:"trigger,omitempty"`
	// Whether or not the 3DS needs to be turned upside-down as this Pok√©mon levels up.
	TurnUpsideDown *bool `json:"turn_upside_down,omitempty"`
}

func (o *EvolutionChainChainEvolutionDetails) GetGender() *int64 {
	if o == nil {
		return nil
	}
	return o.Gender
}

func (o *EvolutionChainChainEvolutionDetails) GetHeldItem() *EvolutionChainChainEvolutionDetailsHeldItem {
	if o == nil {
		return nil
	}
	return o.HeldItem
}

func (o *EvolutionChainChainEvolutionDetails) GetItem() *EvolutionChainChainEvolutionDetailsItem {
	if o == nil {
		return nil
	}
	return o.Item
}

func (o *EvolutionChainChainEvolutionDetails) GetKnownMove() *EvolutionChainChainEvolutionDetailsKnownMove {
	if o == nil {
		return nil
	}
	return o.KnownMove
}

func (o *EvolutionChainChainEvolutionDetails) GetKnownMoveType() *EvolutionChainChainEvolutionDetailsKnownMoveType {
	if o == nil {
		return nil
	}
	return o.KnownMoveType
}

func (o *EvolutionChainChainEvolutionDetails) GetLocation() *EvolutionChainChainEvolutionDetailsLocation {
	if o == nil {
		return nil
	}
	return o.Location
}

func (o *EvolutionChainChainEvolutionDetails) GetMinAffection() *int64 {
	if o == nil {
		return nil
	}
	return o.MinAffection
}

func (o *EvolutionChainChainEvolutionDetails) GetMinBeauty() *int64 {
	if o == nil {
		return nil
	}
	return o.MinBeauty
}

func (o *EvolutionChainChainEvolutionDetails) GetMinHappiness() *int64 {
	if o == nil {
		return nil
	}
	return o.MinHappiness
}

func (o *EvolutionChainChainEvolutionDetails) GetMinLevel() *int64 {
	if o == nil {
		return nil
	}
	return o.MinLevel
}

func (o *EvolutionChainChainEvolutionDetails) GetNeedsOverworldRain() *bool {
	if o == nil {
		return nil
	}
	return o.NeedsOverworldRain
}

func (o *EvolutionChainChainEvolutionDetails) GetPartySpecies() *EvolutionChainChainEvolutionDetailsPartySpecies {
	if o == nil {
		return nil
	}
	return o.PartySpecies
}

func (o *EvolutionChainChainEvolutionDetails) GetPartyType() *EvolutionChainChainEvolutionDetailsPartyType {
	if o == nil {
		return nil
	}
	return o.PartyType
}

func (o *EvolutionChainChainEvolutionDetails) GetRelativePhysicalStats() *int64 {
	if o == nil {
		return nil
	}
	return o.RelativePhysicalStats
}

func (o *EvolutionChainChainEvolutionDetails) GetTimeOfDay() *EvolutionChainChainEvolutionDetailsTimeOfDay {
	if o == nil {
		return nil
	}
	return o.TimeOfDay
}

func (o *EvolutionChainChainEvolutionDetails) GetTradeSpecies() *EvolutionChainChainEvolutionDetailsTradeSpecies {
	if o == nil {
		return nil
	}
	return o.TradeSpecies
}

func (o *EvolutionChainChainEvolutionDetails) GetTrigger() *EvolutionTrigger {
	if o == nil {
		return nil
	}
	return o.Trigger
}

func (o *EvolutionChainChainEvolutionDetails) GetTurnUpsideDown() *bool {
	if o == nil {
		return nil
	}
	return o.TurnUpsideDown
}

type EvolutionChainChain struct {
	// The chain of Pok√©mon species that forms part of this evolution chain
	EvolutionDetails []EvolutionChainChainEvolutionDetails `json:"evolution_details,omitempty"`
	// Whether or not this is a baby Pok√©mon
	IsBaby  *bool           `json:"is_baby,omitempty"`
	Species *PokemonSpecies `json:"species,omitempty"`
}

func (o *EvolutionChainChain) GetEvolutionDetails() []EvolutionChainChainEvolutionDetails {
	if o == nil {
		return nil
	}
	return o.EvolutionDetails
}

func (o *EvolutionChainChain) GetIsBaby() *bool {
	if o == nil {
		return nil
	}
	return o.IsBaby
}

func (o *EvolutionChainChain) GetSpecies() *PokemonSpecies {
	if o == nil {
		return nil
	}
	return o.Species
}

type EvolutionChain struct {
	// The item that a baby Pok√©mon would be holding when born during a forced evolution
	BabyTriggerItem *EvolutionChainBabyTriggerItem `json:"baby_trigger_item,omitempty"`
	Chain           EvolutionChainChain            `json:"chain"`
	// The identifier for this evolution chain resource
	ID int64 `json:"id"`
}

func (o *EvolutionChain) GetBabyTriggerItem() *EvolutionChainBabyTriggerItem {
	if o == nil {
		return nil
	}
	return o.BabyTriggerItem
}

func (o *EvolutionChain) GetChain() EvolutionChainChain {
	if o == nil {
		return EvolutionChainChain{}
	}
	return o.Chain
}

func (o *EvolutionChain) GetID() int64 {
	if o == nil {
		return 0
	}
	return o.ID
}
